import os
import sys


c_macros = [("PY_EXTENSION", None), ]
cython_macros = []

#c99_test_c = """#include <complex.h>
#int main(int argc, char** argv) { float complex a;  return(0); }"""

if 'USE_C99_COMPLEX' in os.environ:
    use_c99 = bool(int(os.environ['USE_C99_COMPLEX']))
else:
    # default to False on non-posix platforms
    # (MSVC doesn't support C99 complex)
    if os.name == 'posix':
        use_c99 = True
    else:
        use_c99 = False
if use_c99:
    c_macros += [("HAVE_C99_COMPLEX", None), ]
    # avoid compiler warnings:  tell Cython to use C99 complex types
    cython_macros += [('CYTHON_CCOMPLEX', 1), ]
    pxi_defines = dict(HAVE_C99_CPLX=1)
    py_defines = dict(_have_c99_complex=1)
else:
    pxi_defines = dict(HAVE_C99_CPLX=0)
    py_defines = dict(_have_c99_complex=0)

# write a file config.pxi that can be included by other .pyx files to determine
# whether or not C99 complex is supported at compile-time
defines_pxi = sys.argv[2]
with open(defines_pxi, 'w') as fd:
    fd.write("# Autogenerated file containing Cython compile-time defines\n\n")
    for k, v in pxi_defines.items():
        fd.write('DEF %s = %d\n' % (k.upper(), int(v)))

# We need this file both in the source dir (to include in sdist/wheel),
# and in the build dir:
for defines_py in [
        os.path.join(os.path.dirname(__file__), '_c99_config.py'),
        sys.argv[1]]:
    with open(defines_py, 'w') as fd:
        fd.write("# Autogenerated file containing compile-time definitions\n\n")
        for k, v in py_defines.items():
            fd.write('%s = %d\n' % (k, int(v)))

